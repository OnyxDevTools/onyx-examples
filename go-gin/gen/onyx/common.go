// Code generated by onyx-gen-go; DO NOT EDIT.
// Generated at: 2026-01-11T05:12:00Z

package onyx

import (
	"context"
	"encoding/json"
	"fmt"
	"time"
	"github.com/OnyxDevTools/onyx-database-go/onyx"
)

// QueryHook allows callers to observe query execution for logging, metrics, or tracing.
// The returned context from BeforeQuery will be used for the operation and passed to AfterQuery.
type QueryHook interface {
	BeforeQuery(ctx context.Context, operation, table string) context.Context
	AfterQuery(ctx context.Context, operation, table string, duration time.Duration, err error)
}

func withContextAndHook(ctx context.Context, timeout time.Duration, hook QueryHook, operation, table string) (context.Context, func(error)) {
	var cancel context.CancelFunc
	if timeout > 0 {
		ctx, cancel = context.WithTimeout(ctx, timeout)
	}
	start := time.Now()
	if hook != nil {
		ctx = hook.BeforeQuery(ctx, operation, table)
	}
	return ctx, func(err error) {
		if hook != nil {
			hook.AfterQuery(ctx, operation, table, time.Since(start), err)
		}
		if cancel != nil {
			cancel()
		}
	}
}

func Eq(field string, value any) onyx.Condition { return onyx.Eq(field, value) }
func Neq(field string, value any) onyx.Condition { return onyx.Neq(field, value) }
func In(field string, values []any) onyx.Condition { return onyx.In(field, values) }
func NotIn(field string, values []any) onyx.Condition { return onyx.NotIn(field, values) }
func Between(field string, from, to any) onyx.Condition { return onyx.Between(field, from, to) }
func Gt(field string, value any) onyx.Condition { return onyx.Gt(field, value) }
func Gte(field string, value any) onyx.Condition { return onyx.Gte(field, value) }
func Lt(field string, value any) onyx.Condition { return onyx.Lt(field, value) }
func Lte(field string, value any) onyx.Condition { return onyx.Lte(field, value) }
func Like(field string, pattern any) onyx.Condition { return onyx.Like(field, pattern) }
func Contains(field string, value any) onyx.Condition { return onyx.Contains(field, value) }
func StartsWith(field string, value any) onyx.Condition { return onyx.StartsWith(field, value) }
func IsNull(field string) onyx.Condition { return onyx.IsNull(field) }
func NotNull(field string) onyx.Condition { return onyx.NotNull(field) }
func Within(field string, query onyx.Query) onyx.Condition { return onyx.Within(field, query) }
func NotWithin(field string, query onyx.Query) onyx.Condition { return onyx.NotWithin(field, query) }
func Asc(field string) onyx.Sort { return onyx.Asc(field) }
func Desc(field string) onyx.Sort { return onyx.Desc(field) }
func Cascade(spec string) onyx.CascadeSpec { return onyx.Cascade(spec) }
func NewCascadeBuilder() onyx.CascadeBuilder { return onyx.NewCascadeBuilder() }

type Schema = onyx.Schema
type Table = onyx.Table
type Field = onyx.Field
type Resolver = onyx.Resolver
type OnyxDocument = onyx.OnyxDocument
type OnyxSecret = onyx.OnyxSecret

var Tables = struct {
	Item string
}{
	Item: "Item",
}

// DB exposes typed table clients backed by the underlying Onyx core client.
type DB struct { core onyx.Client }

type Config = onyx.Config

func New(ctx context.Context, cfg Config) (DB, error) {
	core, err := onyx.Init(ctx, cfg)
	if err != nil {
		return DB{}, err
	}
	return DB{core: core}, nil
}

func Wrap(core onyx.Client) DB { return DB{core: core} }

func (c DB) Core() onyx.Client { return c.core }

func decodeSaved(saved map[string]any, out any) error {
	b, err := json.Marshal(saved)
	if err != nil {
		return err
	}
	return json.Unmarshal(b, out)
}

func decodeList(items []map[string]any, out any) error {
	b, err := json.Marshal(items)
	if err != nil {
		return err
	}
	return json.Unmarshal(b, out)
}

func toAnyStrings(values []string) []any {
	out := make([]any, 0, len(values))
	for _, v := range values {
		out = append(out, v)
	}
	return out
}

func parseCount(v any) (int, error) {
	switch n := v.(type) {
	case int:
		return n, nil
	case int64:
		return int(n), nil
	case float64:
		return int(n), nil
	case json.Number:
		parsed, err := n.Int64()
		if err != nil {
			return 0, err
		}
		return int(parsed), nil
	default:
		return 0, fmt.Errorf("cannot parse count from %T", v)
	}
}

type DocumentsClient struct { core onyx.OnyxDocumentsClient }

func (c DB) Documents() DocumentsClient { return DocumentsClient{core: c.core.Documents()} }

func (d DocumentsClient) List(ctx context.Context) ([]onyx.OnyxDocument, error) { return d.core.List(ctx) }
func (d DocumentsClient) Get(ctx context.Context, id string) (onyx.OnyxDocument, error) { return d.core.Get(ctx, id) }
func (d DocumentsClient) Save(ctx context.Context, doc onyx.OnyxDocument) (onyx.OnyxDocument, error) { return d.core.Save(ctx, doc) }
func (d DocumentsClient) Delete(ctx context.Context, id string) error { return d.core.Delete(ctx, id) }

type OnyxSecretsClient struct { core onyx.Client }

func (c DB) OnyxSecrets() OnyxSecretsClient { return OnyxSecretsClient{core: c.core} }
func (c DB) OnyxSecret() OnyxSecretsClient  { return c.OnyxSecrets() }

func (s OnyxSecretsClient) List(ctx context.Context) ([]onyx.OnyxSecret, error) { return s.core.ListSecrets(ctx) }
func (s OnyxSecretsClient) Get(ctx context.Context, key string) (onyx.OnyxSecret, error) { return s.core.GetSecret(ctx, key) }
func (s OnyxSecretsClient) Set(ctx context.Context, secret onyx.OnyxSecret) (onyx.OnyxSecret, error) { return s.core.PutSecret(ctx, secret) }
func (s OnyxSecretsClient) Delete(ctx context.Context, key string) error { return s.core.DeleteSecret(ctx, key) }

