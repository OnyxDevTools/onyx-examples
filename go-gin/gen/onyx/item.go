// Code generated by onyx-gen-go; DO NOT EDIT.
// Generated at: 2026-01-11T05:12:00Z

package onyx

import (
	"context"
	"time"
	"fmt"
	"github.com/OnyxDevTools/onyx-database-go/onyx"
)

type Item struct {
	Id string `json:"id,omitempty"`
	Name string `json:"name,omitempty"`
}

// ItemUpdates provides typed setters for update operations on Item.
type ItemUpdates struct { values map[string]any }

func NewItemUpdates() *ItemUpdates { return &ItemUpdates{values: make(map[string]any)} }

func (u *ItemUpdates) SetId(v string) *ItemUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["id"] = v
	return u
}

func (u *ItemUpdates) SetName(v string) *ItemUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["name"] = v
	return u
}

func (u *ItemUpdates) valuesMap() map[string]any { return u.values }

type ItemPage struct {
	Items []Item `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type ItemMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

func validateItem(item Item) error {
	if item.Name == "" {
		return fmt.Errorf("item name is required")
	}
	return nil
}

// ItemsClient provides a fluent API for querying and manipulating Item records.
// All methods return a new client instance, allowing for method chaining.
//
// Example:
//   items, err := db.Items().
//       Where(onyx.Eq("isActive", true)).
//       OrderBy("createdAt", false).
//       Limit(10).
//       List(ctx)
type ItemsClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }
// ItemsMapClient provides map-based query helpers returned from Select/GroupBy operations.
type ItemsMapClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }

// ItemRepository captures the full set of ItemsClient operations for easy mocking in tests.
type ItemRepository interface {
	Where(cond onyx.Condition) ItemsClient
	And(cond onyx.Condition) ItemsClient
	Or(cond onyx.Condition) ItemsClient
	Resolve(resolvers ...string) ItemsClient
	OrderBy(field string, asc bool) ItemsClient
	Limit(n int) ItemsClient
	SetUpdates(updates map[string]any) ItemsClient
	SetItemUpdates(updates *ItemUpdates) ItemsClient
	Select(fields ...string) ItemsMapClient
	GroupBy(fields ...string) ItemsMapClient
	AsMaps() ItemsMapClient
	WithTimeout(d time.Duration) ItemsClient
	WithDefaultTimeout() ItemsClient
	WithShortTimeout() ItemsClient
	WithLongTimeout() ItemsClient
	WithHook(h QueryHook) ItemsClient
	Stream(ctx context.Context) (onyx.Iterator, error)
	List(ctx context.Context) ([]Item, error)
	ListMaps(ctx context.Context) ([]map[string]any, error)
	Page(ctx context.Context, cursor string) (ItemPage, error)
	Pages(ctx context.Context) *ItemsPageIterator
	PageOfMaps(ctx context.Context, cursor string) (ItemMapPage, error)
	Update(ctx context.Context) (int, error)
	Delete(ctx context.Context) (int, error)
	Save(ctx context.Context, item Item, cascades ...onyx.CascadeSpec) (Item, error)
	SaveMany(ctx context.Context, items []Item, cascades ...onyx.CascadeSpec) ([]Item, error)
	DeleteByID(ctx context.Context, id string) (int, error)
	DeleteByIDs(ctx context.Context, ids []string) (int, error)
	FindByID(ctx context.Context, id string) (Item, error)
}

// ItemsPageIterator iterates over paginated Item results.
type ItemsPageIterator struct {
	client ItemsClient
	ctx context.Context
	cursor string
	started bool
	page ItemPage
	err error
}

// ItemsMapPageIterator iterates over paginated map results for Item queries.
type ItemsMapPageIterator struct {
	client ItemsMapClient
	ctx context.Context
	cursor string
	started bool
	page ItemMapPage
	err error
}

// Items returns a typed client scoped to the Item table.
func (c DB) Items() ItemsClient { return ItemsClient{core: c.core, q: c.core.From(Tables.Item)} }

func (c ItemsClient) Where(cond onyx.Condition) ItemsClient { c.q = c.q.Where(cond); return c }
func (c ItemsClient) And(cond onyx.Condition) ItemsClient { c.q = c.q.And(cond); return c }
func (c ItemsClient) Or(cond onyx.Condition) ItemsClient { c.q = c.q.Or(cond); return c }
func (c ItemsClient) Resolve(resolvers ...string) ItemsClient { c.q = c.q.Resolve(resolvers...); return c }
func (c ItemsClient) OrderBy(field string, asc bool) ItemsClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c ItemsClient) Limit(n int) ItemsClient { c.q = c.q.Limit(n); return c }
func (c ItemsClient) SetUpdates(updates map[string]any) ItemsClient { c.q = c.q.SetUpdates(updates); return c }
func (c ItemsClient) SetItemUpdates(updates *ItemUpdates) ItemsClient {
	if updates == nil {
		return c
	}
	c.q = c.q.SetUpdates(updates.valuesMap())
	return c
}
func (c ItemsClient) Select(fields ...string) ItemsMapClient {
	c.q = c.q.Select(fields...)
	return ItemsMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}
}
func (c ItemsClient) GroupBy(fields ...string) ItemsMapClient {
	c.q = c.q.GroupBy(fields...)
	return ItemsMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}
}
func (c ItemsClient) AsMaps() ItemsMapClient { return ItemsMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook} }
func (c ItemsClient) WithTimeout(d time.Duration) ItemsClient {
	if d <= 0 {
		c.timeout = 30 * time.Second
		return c
	}
	c.timeout = d
	return c
}
func (c ItemsClient) WithDefaultTimeout() ItemsClient { return c.WithTimeout(30 * time.Second) }
func (c ItemsClient) WithShortTimeout() ItemsClient { return c.WithTimeout(5 * time.Second) }
func (c ItemsClient) WithLongTimeout() ItemsClient { return c.WithTimeout(2 * time.Minute) }
func (c ItemsClient) WithHook(h QueryHook) ItemsClient { c.hook = h; return c }
func (c ItemsClient) Stream(ctx context.Context) (onyx.Iterator, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.Item)
	iter, err := c.q.Stream(ctx)
	done(err)
	return iter, err
}
func (c ItemsClient) List(ctx context.Context) ([]Item, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list", Tables.Item)
	res := onyx.List(ctx, c.q)
	var out []Item
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode Item list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c ItemsClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.Item)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode Item map list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c ItemsClient) Page(ctx context.Context, cursor string) (ItemPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.Item)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page item: %w", err)
		done(err)
		return ItemPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return ItemPage{Items: []Item{}, NextCursor: res.NextCursor}, nil
	}
	var items []Item
	if err := decodeList(res.Items, &items); err != nil {
		err = fmt.Errorf("failed to decode item page: %w", err)
		done(err)
		return ItemPage{}, err
	}
	done(nil)
	return ItemPage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c ItemsClient) Pages(ctx context.Context) *ItemsPageIterator { return &ItemsPageIterator{client: c, ctx: ctx} }

func (c ItemsClient) PageOfMaps(ctx context.Context, cursor string) (ItemMapPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.Item)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page item maps: %w", err)
		done(err)
		return ItemMapPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return ItemMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil
	}
	done(nil)
	return ItemMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c ItemsClient) Update(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.Item)
	n, err := c.q.Update(ctx)
	if err != nil {
		err = fmt.Errorf("failed to update Item: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c ItemsClient) Delete(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.Item)
	n, err := c.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete Item: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c ItemsClient) Save(ctx context.Context, item Item, cascades ...onyx.CascadeSpec) (Item, error) {
	if err := validateItem(item); err != nil {
		return Item{}, err
	}
	var relationships []string
	for i, spec := range cascades {
		if spec == nil {
			return Item{}, fmt.Errorf("cascade spec at index %d is nil", i)
		}
		relationships = append(relationships, spec.String())
	}
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "save", Tables.Item)
	saved, err := c.core.Save(ctx, Tables.Item, item, relationships)
	if err != nil {
		err = fmt.Errorf("failed to save item: %w", err)
		done(err)
		return Item{}, err
	}
	var out Item
	if err := decodeSaved(saved, &out); err != nil {
		err = fmt.Errorf("failed to decode saved item: %w", err)
		done(err)
		return Item{}, err
	}
	done(nil)
	return out, nil
}

func (c ItemsClient) SaveMany(ctx context.Context, items []Item, cascades ...onyx.CascadeSpec) ([]Item, error) {
	if len(items) == 0 {
		return nil, nil
	}
	for i, item := range items {
		if err := validateItem(item); err != nil {
			return nil, fmt.Errorf("item at index %d: %w", i, err)
		}
	}
	var relationships []string
	for i, spec := range cascades {
		if spec == nil {
			return nil, fmt.Errorf("cascade spec at index %d is nil", i)
		}
		relationships = append(relationships, spec.String())
	}
	out := make([]Item, 0, len(items))
	for i, item := range items {
		ctxOp, done := withContextAndHook(ctx, c.timeout, c.hook, "save_many", Tables.Item)
		saved, err := c.core.Save(ctxOp, Tables.Item, item, relationships)
		if err != nil {
			err = fmt.Errorf("failed to save item at index %d: %w", i, err)
			done(err)
			return nil, err
		}
		var decoded Item
		if err := decodeSaved(saved, &decoded); err != nil {
			err = fmt.Errorf("failed to decode saved item at index %d: %w", i, err)
			done(err)
			return nil, err
		}
		done(nil)
		out = append(out, decoded)
	}
	return out, nil
}

func (c ItemsClient) DeleteByID(ctx context.Context, id string) (int, error) {
	if id == "" {
		return 0, fmt.Errorf("item id cannot be empty")
	}
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete_by_id", Tables.Item)
	err := c.core.Delete(ctx, Tables.Item, id)
	if err != nil {
		err = fmt.Errorf("failed to delete item %s: %w", id, err)
		done(err)
		return 0, err
	}
	done(nil)
	return 1, nil
}

func (c ItemsClient) DeleteByIDs(ctx context.Context, ids []string) (int, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	for i, id := range ids {
		if id == "" {
			return 0, fmt.Errorf("id at index %d is empty", i)
		}
	}
	client := c.Where(onyx.In("id", toAnyStrings(ids)))
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "delete_many", Tables.Item)
	n, err := client.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete item by ids: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c ItemsClient) FindByID(ctx context.Context, id string) (Item, error) {
	if id == "" {
		return Item{}, fmt.Errorf("item id cannot be empty")
	}
	items, err := c.Where(onyx.Eq("id", id)).Limit(1).List(ctx)
	if err != nil {
		return Item{}, fmt.Errorf("failed to find item by id %s: %w", id, err)
	}
	if len(items) == 0 {
		return Item{}, nil
	}
	return items[0], nil
}

func (c ItemsMapClient) Where(cond onyx.Condition) ItemsMapClient { c.q = c.q.Where(cond); return c }
func (c ItemsMapClient) And(cond onyx.Condition) ItemsMapClient { c.q = c.q.And(cond); return c }
func (c ItemsMapClient) Or(cond onyx.Condition) ItemsMapClient { c.q = c.q.Or(cond); return c }
func (c ItemsMapClient) Resolve(resolvers ...string) ItemsMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c ItemsMapClient) OrderBy(field string, asc bool) ItemsMapClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c ItemsMapClient) Limit(n int) ItemsMapClient { c.q = c.q.Limit(n); return c }
func (c ItemsMapClient) SetUpdates(updates map[string]any) ItemsMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c ItemsMapClient) Select(fields ...string) ItemsMapClient { c.q = c.q.Select(fields...); return c }
func (c ItemsMapClient) GroupBy(fields ...string) ItemsMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c ItemsMapClient) WithTimeout(d time.Duration) ItemsMapClient {
	if d <= 0 {
		c.timeout = 30 * time.Second
		return c
	}
	c.timeout = d
	return c
}
func (c ItemsMapClient) WithDefaultTimeout() ItemsMapClient { return c.WithTimeout(30 * time.Second) }
func (c ItemsMapClient) WithShortTimeout() ItemsMapClient { return c.WithTimeout(5 * time.Second) }
func (c ItemsMapClient) WithLongTimeout() ItemsMapClient { return c.WithTimeout(2 * time.Minute) }
func (c ItemsMapClient) WithHook(h QueryHook) ItemsMapClient { c.hook = h; return c }
func (c ItemsMapClient) Stream(ctx context.Context) (onyx.Iterator, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.Item)
	iter, err := c.q.Stream(ctx)
	done(err)
	return iter, err
}
func (c ItemsMapClient) List(ctx context.Context) ([]map[string]any, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.Item)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode item map list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c ItemsMapClient) Page(ctx context.Context, cursor string) (ItemMapPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.Item)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page item maps: %w", err)
		done(err)
		return ItemMapPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return ItemMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil
	}
	done(nil)
	return ItemMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c ItemsMapClient) Pages(ctx context.Context) *ItemsMapPageIterator { return &ItemsMapPageIterator{client: c, ctx: ctx} }

func (c ItemsMapClient) Update(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.Item)
	n, err := c.q.Update(ctx)
	if err != nil {
		err = fmt.Errorf("failed to update item maps: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c ItemsMapClient) Delete(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.Item)
	n, err := c.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete item maps: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (it *ItemsPageIterator) Next() bool {
	if it.err != nil {
		return false
	}
	if !it.started {
		it.started = true
		it.err = it.fetch("")
		return it.err == nil
	}
	if it.page.NextCursor == "" {
		return false
	}
	it.err = it.fetch(it.page.NextCursor)
	return it.err == nil
}

func (it *ItemsPageIterator) Page() (ItemPage, error) {
	if it.err != nil {
		return ItemPage{}, it.err
	}
	return it.page, nil
}

func (it *ItemsPageIterator) Err() error { return it.err }

func (it *ItemsPageIterator) fetch(cursor string) error {
	ctx := it.ctx
	client := it.client
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.Item)
	res, err := client.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page item: %w", err)
		done(err)
		return err
	}
	if res.Items == nil {
		it.page = ItemPage{Items: []Item{}, NextCursor: res.NextCursor}
		done(nil)
		return nil
	}
	var items []Item
	if err := decodeList(res.Items, &items); err != nil {
		err = fmt.Errorf("failed to decode item page: %w", err)
		done(err)
		return err
	}
	it.page = ItemPage{Items: items, NextCursor: res.NextCursor}
	done(nil)
	return nil
}

func (it *ItemsMapPageIterator) Next() bool {
	if it.err != nil {
		return false
	}
	if !it.started {
		it.started = true
		it.err = it.fetch("")
		return it.err == nil
	}
	if it.page.NextCursor == "" {
		return false
	}
	it.err = it.fetch(it.page.NextCursor)
	return it.err == nil
}

func (it *ItemsMapPageIterator) Page() (ItemMapPage, error) {
	if it.err != nil {
		return ItemMapPage{}, it.err
	}
	return it.page, nil
}

func (it *ItemsMapPageIterator) Err() error { return it.err }

func (it *ItemsMapPageIterator) fetch(cursor string) error {
	ctx := it.ctx
	client := it.client
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.Item)
	res, err := client.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page item maps: %w", err)
		done(err)
		return err
	}
	if res.Items == nil {
		it.page = ItemMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}
		done(nil)
		return nil
	}
	it.page = ItemMapPage{Items: res.Items, NextCursor: res.NextCursor}
	done(nil)
	return nil
}

